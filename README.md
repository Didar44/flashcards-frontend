Учебные Флешкарты

Краткое описание проекта:

Это веб-приложение для обучения с использованием флешкарточек. Пользователи могут выбрать предмет, решать задачи в различных режимах (флешкарты, тесты, обучение, сопоставление) и отслеживать свой прогресс. Каждый режим предоставляет различные способы взаимодействия с карточками и позволяет лучше запомнить информацию.

Инструкции по установке и запуску:
	1.	Клонируйте репозиторий:git clone https://github.com/Didar44/flashcards-frontend.git
cd flashcards-frontend
2.	Установите зависимости:
Для установки зависимостей выполните команду:
npm install
3.	Запустите приложение:
После установки зависимостей, запустите приложение с помощью команды:
npm start
Это откроет приложение в браузере по адресу http://localhost:3000.

	4.	Запуск проекта в продакшн-режиме:
Для запуска приложения в продакшн-режиме используйте команду:
npm run build

После этого можно развернуть приложение на сервере.

Описание процесса проектирования и разработки:
	•	Проект разработан с использованием React для frontend и TypeScript для статической типизации. Backend был подключен через API для получения данных о предметах и карточках.
	•	В качестве UI-библиотеки использован CSS, для простоты и легкости разработки. В некоторых частях UI используется React Hooks (useState, useEffect) для управления состоянием приложения.
	•	Для организации роутинга использовалась стандартная система React без дополнительного фреймворка роутинга, так как приложение не имеет сложной структуры с множеством разных страниц.
	•	В проекте реализованы несколько режимов работы с карточками: Learn, Match, Flashcards, Test. Эти режимы обеспечивают различные способы взаимодействия с пользователем и тренировку памяти.

Информация об уникальных подходах или методологиях, использованных в работе:
	•	Использование localStorage для сохранения прогресса пользователя между сессиями. Это позволяет пользователю вернуться к приложению и продолжить с того места, где он остановился.
	•	Прогресс по карточкам: при каждом взаимодействии с карточками пользователь может пометить их как “знаю” или “не знаю”, и это отражается на прогрессе. Это помогает отслеживать, какие карточки нуждаются в повторении.
	•	Реализация таймеров и подсказок: в некоторых режимах используется таймер для создания временных ограничений, а также подсказки, которые отображаются, если пользователь не может ответить на вопрос.

Обсуждение компромиссов, принятых во время разработки:
	•	Вначале рассматривался вариант использования более сложного стека с серверной частью (например, использование Node.js или Flask). Однако для упрощения процесса разработки было принято решение использовать минимальный backend, который предоставляет данные через API.
	•	В некоторых режимах были сделаны упрощения для быстроты разработки: например, не использовались сложные алгоритмы для подсчета результатов, а базовое взаимодействие с карточками и простая логика выбора варианта ответа были достаточными.

Описание известных ошибок или проблем в приложении:
	•	В режиме Match возможны ситуации, когда некоторые карточки не могут быть сопоставлены, если их порядок изменяется, что может затруднить взаимодействие.
	•	Таймеры иногда могут не синхронизироваться должным образом при переключении между режимами, что может приводить к несоответствию времени на разных этапах.
	•	Некоторые карточки с ошибками или неполной информацией в вопросах и ответах могут быть не совсем точными, что может повлиять на результаты тестов.

Почему был выбран этот технический стек:
	•	React + TypeScript: Мы выбрали React для создания динамичных пользовательских интерфейсов с учетом его гибкости и широкого сообщества. TypeScript был выбран для улучшения читаемости и поддерживаемости кода, а также для обеспечения статической типизации, что уменьшает вероятность ошибок.
	•	CSS для стилей был выбран, так как проект не требует использования сложных стилей и анимаций, и для этого подходящего инструмента хватает.
	•	API для взаимодействия с backend было использовано для асинхронной загрузки данных, что позволяет разделить frontend и backend и делает приложение более гибким и масштабируемым.